<!doctype html>
<html lang="en"> 
 <head> 
  <meta charset="utf-8"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/"> 
  <title>Much Ado About Traversal — The Pyramid Web Framework v2.0</title> 
  <link rel="stylesheet" type="text/css" href="../_static/pygments.css"> 
  <link rel="stylesheet" type="text/css" href="../_static/pylons.css"> 
  <link rel="stylesheet" type="text/css" href="../_static/copybutton.css"> 
  <link rel="stylesheet" type="text/css" href="https://assets.readthedocs.org/static/css/badge_only.css"> 
  <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script> 
  <script src="../_static/jquery.js"></script> 
  <script src="../_static/underscore.js"></script> 
  <script src="../_static/doctools.js"></script> 
  <script src="../_static/clipboard.min.js"></script> 
  <script src="../_static/copybutton.js"></script> 
  <script async src="https://assets.readthedocs.org/static/javascript/readthedocs-doc-embed.js"></script> 
  <link rel="canonical" href="https://docs.pylonsproject.org/projects/pyramid/en/latest/narr/muchadoabouttraversal.html"> 
  <link rel="index" title="Index" href="../genindex.html"> 
  <link rel="search" title="Search" href="../search.html"> 
  <link rel="copyright" title="Copyright" href="../copyright.html"> 
  <link rel="next" title="Traversal" href="traversal.html"> 
  <link rel="prev" title="Hello Traversal World" href="hellotraversal.html"> 
  <link rel="stylesheet" href="//static.pylonsproject.org/fonts/nobile/stylesheet.css" type="text/css" media="screen" charset="utf-8"> 
  <link rel="stylesheet" href="//static.pylonsproject.org/fonts/neuton/stylesheet.css" type="text/css" media="screen" charset="utf-8"> <!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]--> 
  <link rel="shortcut icon" href="../_static/pyramid.ico"> <!-- RTD Extra Head --> 
  <link rel="stylesheet" href="https://assets.readthedocs.org/static/css/readthedocs-doc-embed.css" type="text/css"> 
  <script type="application/json" id="READTHEDOCS_DATA">{"ad_free": false, "api_host": "https://readthedocs.org", "build_date": "2022-04-22T10:08:39Z", "builder": "sphinx", "canonical_url": null, "commit": "1f887bd8", "docroot": "/docs/", "features": {"docsearch_disabled": false}, "global_analytics_code": "UA-17997319-1", "language": "en", "page": "narr/muchadoabouttraversal", "programming_language": "py", "project": "pyramid", "proxied_api_host": "/_", "source_suffix": ".rst", "subprojects": {}, "theme": "pyramid", "user_analytics_code": "G-V7CJBMK66P", "version": "latest"}</script> <!--
Using this variable directly instead of using `JSON.parse` is deprecated.
The READTHEDOCS_DATA global variable will be removed in the future.
--> 
  <script type="text/javascript">
READTHEDOCS_DATA = JSON.parse(document.getElementById('READTHEDOCS_DATA').innerHTML);
</script> 
  <script type="text/javascript" src="https://assets.readthedocs.org/static/javascript/readthedocs-analytics.js" async></script> <!-- end RTD <extrahead> --> 
 </head>
 <body> <a href="https://github.com/Pylons/pyramid/blob/2.0-branch/docs/narr/muchadoabouttraversal.rst"><img style="position: absolute; top: 0; right: 0; border: 0;" src="../_static/edit-me-on-github.png" alt="Edit me on GitHub"></a> 
  <div class="header-small"> 
   <div class="logo-small"> <a href="../index.html"> <img class="logo" src="../_static/pyramid-small.png" alt="Logo"> </a> 
   </div> 
  </div> 
  <div class="related" role="navigation" aria-label="related navigation"> 
   <h3>Navigation</h3> 
   <ul> 
    <li class="right" style="margin-right: 10px"> <a href="../genindex.html" title="General Index" accesskey="I">index</a></li> 
    <li class="right"> <a href="../py-modindex.html" title="Python Module Index">modules</a> |</li> 
    <li class="right"> <a href="traversal.html" title="Traversal" accesskey="N">next</a> |</li> 
    <li class="right"> <a href="hellotraversal.html" title="Hello Traversal World" accesskey="P">previous</a> |</li> 
    <li><a href="../index.html">The Pyramid Web Framework v2.0</a> »</li> 
    <li class="nav-item nav-item-this"><a href="">Much Ado About Traversal</a></li> 
   </ul> 
  </div> 
  <div class="document"> 
   <div class="documentwrapper"> 
    <div class="bodywrapper"> 
     <div class="body" role="main"> 
      <section id="much-ado-about-traversal"> <span id="much-ado-about-traversal-chapter"></span>
       <h1>Much Ado About Traversal<a class="headerlink" href="#much-ado-about-traversal" title="Permalink to this headline">¶</a></h1> 
       <p>(Or, why you should care about it.)</p> 
       <div class="admonition note"> 
        <p class="admonition-title">Note</p> 
        <p>This chapter was adapted, with permission, from a blog post by Rob Miller.</p> 
       </div> 
       <p>Traversal is an alternative to <a class="reference internal" href="../glossary.html#term-URL-dispatch"><span class="xref std std-term">URL dispatch</span></a> which allows <span>Pyramid</span> applications to map URLs to code.</p> 
       <div class="admonition note"> 
        <p class="admonition-title">Note</p> 
        <p>Ex-Zope users who are already familiar with traversal and view lookup conceptually may want to skip directly to the <a class="reference internal" href="traversal.html#traversal-chapter"><span class="std std-ref">Traversal</span></a> chapter, which discusses technical details. This chapter is mostly aimed at people who have previous <a class="reference internal" href="../glossary.html#term-Pylons"><span class="xref std std-term">Pylons</span></a> experience or experience in another framework which does not provide traversal, and need an introduction to the "why" of traversal.</p> 
       </div> 
       <p>Some folks who have been using Pylons and its Routes-based URL matching for a long time are being exposed for the first time, via <span>Pyramid</span>, to new ideas such as "<a class="reference internal" href="../glossary.html#term-traversal"><span class="xref std std-term">traversal</span></a>" and "<a class="reference internal" href="../glossary.html#term-View-Lookup"><span class="xref std std-term">view lookup</span></a>" as a way to route incoming HTTP requests to callable code. Some of the same folks believe that traversal is hard to understand. Others question its usefulness; URL matching has worked for them so far, so why should they even consider dealing with another approach, one which doesn't fit their brain and which doesn't provide any immediately obvious value?</p> 
       <p>You can be assured that if you don't want to understand traversal, you don't have to. You can happily build <span>Pyramid</span> applications with only <a class="reference internal" href="../glossary.html#term-URL-dispatch"><span class="xref std std-term">URL dispatch</span></a>. However, there are some straightforward, real-world use cases that are much more easily served by a traversal-based approach than by a pattern-matching mechanism. Even if you haven't yet hit one of these use cases yourself, understanding these new ideas is worth the effort for any web developer so you know when you might want to use them. <a class="reference internal" href="../glossary.html#term-traversal"><span class="xref std std-term">Traversal</span></a> is actually a straightforward metaphor easily comprehended by anyone who's ever used a run-of-the-mill file system with folders and files.</p> 
       <section id="url-dispatch"> <span id="index-0"></span>
        <h2>URL Dispatch<a class="headerlink" href="#url-dispatch" title="Permalink to this headline">¶</a></h2> 
        <p>Let's step back and consider the problem we're trying to solve. An HTTP request for a particular path has been routed to our web application. The requested path will possibly invoke a specific <a class="reference internal" href="../glossary.html#term-view-callable"><span class="xref std std-term">view callable</span></a> function defined somewhere in our app. We're trying to determine <em>which</em> callable function, if any, should be invoked for a given requested URL.</p> 
        <p>Many systems, including Pyramid, offer a simple solution. They offer the concept of "URL matching". URL matching approaches this problem by parsing the URL path and comparing the results to a set of registered "patterns", defined by a set of regular expressions or some other URL path templating syntax. Each pattern is mapped to a callable function somewhere; if the request path matches a specific pattern, the associated function is called. If the request path matches more than one pattern, some conflict resolution scheme is used, usually a simple order precedence so that the first match will take priority over any subsequent matches. If a request path doesn't match any of the defined patterns, a "404 Not Found" response is returned.</p> 
        <p>In Pyramid, we offer an implementation of URL matching which we call <a class="reference internal" href="../glossary.html#term-URL-dispatch"><span class="xref std std-term">URL dispatch</span></a>. Using <span>Pyramid</span> syntax, we might have a match pattern such as <code class="docutils literal notranslate"><span class="pre">/{userid}/photos/{photoid}</span></code>, mapped to a <code class="docutils literal notranslate"><span class="pre">photo_view()</span></code> function defined somewhere in our code. Then a request for a path such as <code class="docutils literal notranslate"><span class="pre">/joeschmoe/photos/photo1</span></code> would be a match, and the <code class="docutils literal notranslate"><span class="pre">photo_view()</span></code> function would be invoked to handle the request. Similarly, <code class="docutils literal notranslate"><span class="pre">/{userid}/blog/{year}/{month}/{postid}</span></code> might map to a <code class="docutils literal notranslate"><span class="pre">blog_post_view()</span></code> function, so <code class="docutils literal notranslate"><span class="pre">/joeschmoe/blog/2010/12/urlmatching</span></code> would trigger the function, which presumably would know how to find and render the <code class="docutils literal notranslate"><span class="pre">urlmatching</span></code> blog post.</p> 
       </section> 
       <section id="historical-refresher"> 
        <h2>Historical Refresher<a class="headerlink" href="#historical-refresher" title="Permalink to this headline">¶</a></h2> 
        <p>Now that we've refreshed our understanding of <a class="reference internal" href="../glossary.html#term-URL-dispatch"><span class="xref std std-term">URL dispatch</span></a>, we'll dig in to the idea of traversal. Before we do, though, let's take a trip down memory lane. If you've been doing web work for a while, you may remember a time when we didn't have fancy web frameworks like <a class="reference internal" href="../glossary.html#term-Pylons"><span class="xref std std-term">Pylons</span></a> and <span>Pyramid</span>. Instead, we had general purpose HTTP servers that primarily served files off of a file system. The "root" of a given site mapped to a particular folder somewhere on the file system. Each segment of the request URL path represented a subdirectory. The final path segment would be either a directory or a file, and once the server found the right file it would package it up in an HTTP response and send it back to the client. So serving up a request for <code class="docutils literal notranslate"><span class="pre">/joeschmoe/photos/photo1</span></code> literally meant that there was a <code class="docutils literal notranslate"><span class="pre">joeschmoe</span></code> folder somewhere, which contained a <code class="docutils literal notranslate"><span class="pre">photos</span></code> folder, which in turn contained a <code class="docutils literal notranslate"><span class="pre">photo1</span></code> file. If at any point along the way we find that there is not a folder or file matching the requested path, we return a 404 response.</p> 
        <p>As the web grew more dynamic, however, a little bit of extra complexity was added. Technologies such as CGI and HTTP server modules were developed. Files were still looked up on the file system, but if the file ended with (for example) <code class="docutils literal notranslate"><span class="pre">.cgi</span></code> or <code class="docutils literal notranslate"><span class="pre">.php</span></code>, or if it lived in a special folder, instead of simply sending the file to the client the server would read the file, execute it using an interpreter of some sort, and then send the output from this process to the client as the final result. The server configuration specified which files would trigger some dynamic code, with the default case being to just serve the static file.</p> 
       </section> 
       <section id="traversal-a-k-a-resource-location"> <span id="index-1"></span>
        <h2>Traversal (a.k.a., Resource Location)<a class="headerlink" href="#traversal-a-k-a-resource-location" title="Permalink to this headline">¶</a></h2> 
        <p>Believe it or not, if you understand how serving files from a file system works, you understand traversal. And if you understand that a server might do something different based on what type of file a given request specifies, then you understand view lookup.</p> 
        <p>The major difference between file system lookup and traversal is that a file system lookup steps through nested directories and files in a file system tree, while traversal steps through nested dictionary-type objects in a <a class="reference internal" href="../glossary.html#term-resource-tree"><span class="xref std std-term">resource tree</span></a>. Let's take a detailed look at one of our example paths, so we can see what I mean.</p> 
        <p>The path <code class="docutils literal notranslate"><span class="pre">/joeschmoe/photos/photo1</span></code>, has four segments: <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">joeschmoe</span></code>, <code class="docutils literal notranslate"><span class="pre">photos</span></code> and <code class="docutils literal notranslate"><span class="pre">photo1</span></code>. With file system lookup we might have a root folder (<code class="docutils literal notranslate"><span class="pre">/</span></code>) containing a nested folder (<code class="docutils literal notranslate"><span class="pre">joeschmoe</span></code>), which contains another nested folder (<code class="docutils literal notranslate"><span class="pre">photos</span></code>), which finally contains a JPG file (<code class="docutils literal notranslate"><span class="pre">photo1</span></code>). With traversal, we instead have a dictionary-like root object. Asking for the <code class="docutils literal notranslate"><span class="pre">joeschmoe</span></code> key gives us another dictionary-like object. Asking in turn for the <code class="docutils literal notranslate"><span class="pre">photos</span></code> key gives us yet another mapping object, which finally (hopefully) contains the resource that we're looking for within its values, referenced by the <code class="docutils literal notranslate"><span class="pre">photo1</span></code> key.</p> 
        <p>In pure Python terms, then, the traversal or "resource location" portion of satisfying the <code class="docutils literal notranslate"><span class="pre">/joeschmoe/photos/photo1</span></code> request will look something like this pseudocode:</p> 
        <div class="highlight-default notranslate">
         <div class="highlight">
          <pre><span></span><span class="n">get_root</span><span class="p">()[</span><span class="s1">'joeschmoe'</span><span class="p">][</span><span class="s1">'photos'</span><span class="p">][</span><span class="s1">'photo1'</span><span class="p">]</span>
</pre>
         </div> 
        </div> 
        <p><code class="docutils literal notranslate"><span class="pre">get_root()</span></code> is some function that returns a root traversal <a class="reference internal" href="../glossary.html#term-resource"><span class="xref std std-term">resource</span></a>. If all of the specified keys exist, then the returned object will be the resource that is being requested, analogous to the JPG file that was retrieved in the file system example. If a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.10)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> is generated anywhere along the way, <span>Pyramid</span> will return 404. (This isn't precisely true, as you'll see when we learn about view lookup below, but the basic idea holds.)</p> 
       </section> 
       <section id="what-is-a-resource"> <span id="index-2"></span>
        <h2>What Is a "Resource"?<a class="headerlink" href="#what-is-a-resource" title="Permalink to this headline">¶</a></h2> 
        <p>"Files on a file system I understand", you might say. "But what are these nested dictionary things? Where do these objects, these 'resources', live? What <em>are</em> they?"</p> 
        <p>Since <span>Pyramid</span> is not a highly opinionated framework, it makes no restriction on how a <a class="reference internal" href="../glossary.html#term-resource"><span class="xref std std-term">resource</span></a> is implemented; a developer can implement them as they wish. One common pattern used is to persist all of the resources, including the root, in a database as a graph. The root object is a dictionary-like object. Dictionary-like objects in Python supply a <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> method which is called when key lookup is done. Under the hood, when <code class="docutils literal notranslate"><span class="pre">adict</span></code> is a dictionary-like object, Python translates <code class="docutils literal notranslate"><span class="pre">adict['a']</span></code> to <code class="docutils literal notranslate"><span class="pre">adict.__getitem__('a')</span></code>. Try doing this in a Python interpreter prompt if you don't believe us:</p> 
        <div class="doctest highlight-default notranslate">
         <div class="highlight">
          <pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adict</span><span class="p">[</span><span class="s1">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adict</span><span class="p">[</span><span class="s1">'a'</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="go">1</span>
</pre>
         </div> 
        </div> 
        <p>The dictionary-like root object stores the ids of all of its subresources as keys, and provides a <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> implementation that fetches them. So <code class="docutils literal notranslate"><span class="pre">get_root()</span></code> fetches the unique root object, while <code class="docutils literal notranslate"><span class="pre">get_root()['joeschmoe']</span></code> returns a different object, also stored in the database, which in turn has its own subresources and <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> implementation, and so on. These resources might be persisted in a relational database, one of the many "NoSQL" solutions that are becoming popular these days, or anywhere else; it doesn't matter. As long as the returned objects provide the dictionary-like API (i.e., as long as they have an appropriately implemented <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> method), then traversal will work.</p> 
        <p>In fact, you don't need a "database" at all. You could use plain dictionaries, with your site's URL structure hard-coded directly in the Python source. Or you could trivially implement a set of objects with <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> methods that search for files in specific directories, and thus precisely recreate the traditional mechanism of having the URL path mapped directly to a folder structure on the file system. Traversal is in fact a superset of file system lookup.</p> 
        <div class="admonition note"> 
         <p class="admonition-title">Note</p> 
         <p>See the chapter entitled <a class="reference internal" href="resources.html#resources-chapter"><span class="std std-ref">Resources</span></a> for a more technical overview of resources.</p> 
        </div> 
       </section> 
       <section id="view-lookup"> <span id="index-3"></span>
        <h2>View Lookup<a class="headerlink" href="#view-lookup" title="Permalink to this headline">¶</a></h2> 
        <p>At this point we're nearly there. We've covered traversal, which is the process by which a specific resource is retrieved according to a specific URL path. But what is "view lookup"?</p> 
        <p>The need for view lookup is simple: there is more than one possible action that you might want to take after finding a <a class="reference internal" href="../glossary.html#term-resource"><span class="xref std std-term">resource</span></a>. With our photo example, for instance, you might want to view the photo in a page, but you might also want to provide a way for the user to edit the photo and any associated metadata. We'll call the former the <code class="docutils literal notranslate"><span class="pre">view</span></code> view, and the latter will be the <code class="docutils literal notranslate"><span class="pre">edit</span></code> view. (Original, I know.) <span>Pyramid</span> has a centralized view <a class="reference internal" href="../glossary.html#term-application-registry"><span class="xref std std-term">application registry</span></a> where named views can be associated with specific resource types. So in our example, we'll assume that we've registered <code class="docutils literal notranslate"><span class="pre">view</span></code> and <code class="docutils literal notranslate"><span class="pre">edit</span></code> views for photo objects, and that we've specified the <code class="docutils literal notranslate"><span class="pre">view</span></code> view as the default, so that <code class="docutils literal notranslate"><span class="pre">/joeschmoe/photos/photo1/view</span></code> and <code class="docutils literal notranslate"><span class="pre">/joeschmoe/photos/photo1</span></code> are equivalent. The edit view would sensibly be provided by a request for <code class="docutils literal notranslate"><span class="pre">/joeschmoe/photos/photo1/edit</span></code>.</p> 
        <p>Hopefully it's clear that the first portion of the edit view's URL path is going to resolve to the same resource as the non-edit version, specifically the resource returned by <code class="docutils literal notranslate"><span class="pre">get_root()['joeschmoe']['photos']['photo1']</span></code>. But traversal ends there; the <code class="docutils literal notranslate"><span class="pre">photo1</span></code> resource doesn't have an <code class="docutils literal notranslate"><span class="pre">edit</span></code> key. In fact, it might not even be a dictionary-like object, in which case <code class="docutils literal notranslate"><span class="pre">photo1['edit']</span></code> would be meaningless. When the <span>Pyramid</span> resource location has been resolved to a <em>leaf</em> resource, but the entire request path has not yet been expended, the <em>very next</em> path segment is treated as a <a class="reference internal" href="../glossary.html#term-view-name"><span class="xref std std-term">view name</span></a>. The registry is then checked to see if a view of the given name has been specified for a resource of the given type. If so, the view callable is invoked, with the resource passed in as the related <code class="docutils literal notranslate"><span class="pre">context</span></code> object (also available as <code class="docutils literal notranslate"><span class="pre">request.context</span></code>). If a view callable could not be found, <span>Pyramid</span> will return a "404 Not Found" response.</p> 
        <p>You might conceptualize a request for <code class="docutils literal notranslate"><span class="pre">/joeschmoe/photos/photo1/edit</span></code> as ultimately converted into the following piece of Pythonic pseudocode:</p> 
        <div class="highlight-default notranslate">
         <div class="highlight">
          <pre><span></span><span class="n">context</span> <span class="o">=</span> <span class="n">get_root</span><span class="p">()[</span><span class="s1">'joeschmoe'</span><span class="p">][</span><span class="s1">'photos'</span><span class="p">][</span><span class="s1">'photo1'</span><span class="p">]</span>
<span class="n">view_callable</span> <span class="o">=</span> <span class="n">get_view</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="s1">'edit'</span><span class="p">)</span>
<span class="n">request</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
<span class="n">view_callable</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
</pre>
         </div> 
        </div> 
        <p>The <code class="docutils literal notranslate"><span class="pre">get_root</span></code> and <code class="docutils literal notranslate"><span class="pre">get_view</span></code> functions don't really exist. Internally, <span>Pyramid</span> does something more complicated. But the example above is a reasonable approximation of the view lookup algorithm in pseudocode.</p> 
       </section> 
       <section id="use-cases"> 
        <h2>Use Cases<a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h2> 
        <p>Why should we care about traversal? URL matching is easier to explain, and it's good enough, right?</p> 
        <p>In some cases, yes, but certainly not in all cases. So far we've had very structured URLs, where our paths have had a specific, small number of pieces, like this:</p> 
        <div class="highlight-default notranslate">
         <div class="highlight">
          <pre><span></span><span class="o">/</span><span class="p">{</span><span class="n">userid</span><span class="p">}</span><span class="o">/</span><span class="p">{</span><span class="n">typename</span><span class="p">}</span><span class="o">/</span><span class="p">{</span><span class="n">objectid</span><span class="p">}[</span><span class="o">/</span><span class="p">{</span><span class="n">view_name</span><span class="p">}]</span>
</pre>
         </div> 
        </div> 
        <p>In all of the examples thus far, we've hard coded the typename value, assuming that we'd know at development time what names were going to be used ("photos", "blog", etc.). But what if we don't know what these names will be? Or, worse yet, what if we don't know <em>anything</em> about the structure of the URLs inside a user's folder? We could be writing a CMS where we want the end user to be able to arbitrarily add content and other folders inside his folder. He might decide to nest folders dozens of layers deep. How will you construct matching patterns that could account for every possible combination of paths that might develop?</p> 
        <p>It might be possible, but it certainly won't be easy. The matching patterns are going to become complex quickly as you try to handle all of the edge cases.</p> 
        <p>With traversal, however, it's straightforward. Twenty layers of nesting would be no problem. <span>Pyramid</span> will happily call <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> as many times as it needs to, until it runs out of path segments or until a resource raises a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.10)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>. Each resource only needs to know how to fetch its immediate children, and the traversal algorithm takes care of the rest. Also, since the structure of the resource tree can live in the database and not in the code, it's simple to let users modify the tree at runtime to set up their own personalized "directory" structures.</p> 
        <p>Another use case in which traversal shines is when there is a need to support a context-dependent security policy. One example might be a document management infrastructure for a large corporation, where members of different departments have varying access levels to the various other departments' files. Reasonably, even specific files might need to be made available to specific individuals. Traversal does well here if your resources actually represent the data objects related to your documents, because the idea of a resource authorization is baked right into the code resolution and calling process. Resource objects can store ACLs, which can be inherited and/or overridden by the subresources.</p> 
        <p>If each resource can thus generate a context-based ACL, then whenever view code is attempting to perform a sensitive action, it can check against that ACL to see whether the current user should be allowed to perform the action. In this way you achieve so called "instance based" or "row level" security which is considerably harder to model using a traditional tabular approach. <span>Pyramid</span> actively supports such a scheme, and in fact if you register your views with guarded permissions and use an authorization policy, <span>Pyramid</span> can check against a resource's ACL when deciding whether or not the view itself is available to the current user.</p> 
        <p>In summary, there are entire classes of problems that are more easily served by traversal and view lookup than by <a class="reference internal" href="../glossary.html#term-URL-dispatch"><span class="xref std std-term">URL dispatch</span></a>. If your problems don't require it, great, stick with <a class="reference internal" href="../glossary.html#term-URL-dispatch"><span class="xref std std-term">URL dispatch</span></a>. But if you're using <span>Pyramid</span> and you ever find that you <em>do</em> need to support one of these use cases, you'll be glad you have traversal in your toolkit.</p> 
        <div class="admonition note"> 
         <p class="admonition-title">Note</p> 
         <p>It is even possible to mix and match <a class="reference internal" href="../glossary.html#term-traversal"><span class="xref std std-term">traversal</span></a> with <a class="reference internal" href="../glossary.html#term-URL-dispatch"><span class="xref std std-term">URL dispatch</span></a> in the same <span>Pyramid</span> application. See the <a class="reference internal" href="hybrid.html#hybrid-chapter"><span class="std std-ref">Combining Traversal and URL Dispatch</span></a> chapter for details.</p> 
        </div> 
       </section> 
      </section> 
      <div class="clearer"></div> 
     </div> 
    </div> 
   </div> 
   <div class="sphinxsidebar" role="navigation" aria-label="main navigation"> 
    <div class="sphinxsidebarwrapper"> 
     <div> 
      <h3><a href="../index.html">Table of Contents</a></h3> 
      <ul> 
       <li><a class="reference internal" href="#">Much Ado About Traversal</a>
        <ul> 
         <li><a class="reference internal" href="#url-dispatch">URL Dispatch</a></li> 
         <li><a class="reference internal" href="#historical-refresher">Historical Refresher</a></li> 
         <li><a class="reference internal" href="#traversal-a-k-a-resource-location">Traversal (a.k.a., Resource Location)</a></li> 
         <li><a class="reference internal" href="#what-is-a-resource">What Is a "Resource"?</a></li> 
         <li><a class="reference internal" href="#view-lookup">View Lookup</a></li> 
         <li><a class="reference internal" href="#use-cases">Use Cases</a></li> 
        </ul> </li> 
      </ul> 
     </div><!-- Ethical ad insertion --> 
     <div id="ethical-ad-placement"></div> 
     <div> 
      <h4>Previous topic</h4> 
      <p class="topless"><a href="hellotraversal.html" title="previous chapter">Hello Traversal World</a></p> 
     </div> 
     <div> 
      <h4>Next topic</h4> 
      <p class="topless"><a href="traversal.html" title="next chapter">Traversal</a></p> 
     </div> 
     <div role="note" aria-label="source link"> 
      <h3>This Page</h3> 
      <ul class="this-page-menu"> 
       <li><a href="../_sources/narr/muchadoabouttraversal.rst.txt" rel="nofollow">Show Source</a></li> 
      </ul> 
     </div> 
     <div id="searchbox" style="display: none" role="search"> 
      <h3 id="searchlabel">Quick search</h3> 
      <div class="searchformwrapper"> 
       <form class="search" action="../search.html" method="get"> 
        <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"> 
        <input type="submit" value="Go"> 
       </form> 
      </div> 
     </div> 
     <script>$('#searchbox').show(0);</script> 
    </div> 
   </div> 
   <div class="clearer"></div> 
  </div> 
  <div class="related" role="navigation" aria-label="related navigation"> 
   <h3>Navigation</h3> 
   <ul> 
    <li class="right" style="margin-right: 10px"> <a href="../genindex.html" title="General Index">index</a></li> 
    <li class="right"> <a href="../py-modindex.html" title="Python Module Index">modules</a> |</li> 
    <li class="right"> <a href="traversal.html" title="Traversal">next</a> |</li> 
    <li class="right"> <a href="hellotraversal.html" title="Hello Traversal World">previous</a> |</li> 
    <li><a href="../index.html">The Pyramid Web Framework v2.0</a> »</li> 
    <li class="nav-item nav-item-this"><a href="">Much Ado About Traversal</a></li> 
   </ul> 
  </div> 
  <div class="footer" role="contentinfo">
    © <a href="../copyright.html">Copyright</a> 2008-2022, Agendaless Consulting. Last updated on Apr 22, 2022. Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0. 
  </div>  
 </body>
</html>